blueprint:
  name: EMHASS Deferrable Load Controller (v202601)
  description: |
    This blueprint manages the complete lifecycle of a **single deferrable load** for EMHASS.
    It acts as the interface between your physical device (e.g., a switch) and the main `EMHASS Basic Automation`.

    You will need one automation based on this blueprint **for each** deferrable load you want to control.

    **Core Functions:**
    * **State Management:** Controls an `input_select` helper to track the load's state (`done`, `wait`, `running`, `force`).
    * **Configuration Output:** Generates the necessary JSON configuration in an `input_text` helper.
    * **Device Control:** Starts and stops your physical device (e.g., `switch`, `input_number`) based on the EMHASS optimization plan.
    * **Flexible Strategies:** Provides multiple strategies to define how a load is started (e.g., by EMHASS) and how it's marked as complete (e.g., by a power sensor).

    **Requirements:**
    * The [EMHASS: Energy Management Optimization for Home Assistant](https://github.com/davidusb-geek/emhass) add-on.
    * The `EMHASS Basic Automation` blueprint (emhass_basic.yaml) must be installed and configured.
    * For each load, you must create two Home Assistant Helpers:
        1.  An `input_text` helper (max 255 chars) for the JSON data.
        2.  An `input_select` helper with the options: `done`, `wait`, `running`, `force`.

    **Setup:**
    After configuring this automation, you **must** add the `input_text` helper you created to the "List of EMHASS Deferrable Loads" input in your main `EMHASS Basic Automation`.
  domain: automation
  source_url: https://github.com/DanielBY27/Home-Assistant/blob/main/blueprints/automation/emhass_basic_trigger.yaml
  author: DanielBY27
  homeassistant:
    min_version: 2025.10.0

# ------------------------
# --- EMHASS Trigger Input
# ------------------------

  input:

    # --- EMHASS Trigger
    grid_basic_trigger_config:
      name: Load Control & State Management
      description: >
        Configures the core logic: Which entities are used for the status, when the charging process is set to 'wait', and when it is 'done'.
      collapsed: true
      input:
        trigger_strategy:
          name: Control Strategy (Start- & Stop-Logic)
          description: |
            Defines how the automation controls the charging process. Choose a strategy based on how your device is controlled.
            **Wait:** When does the load enter the 'wait' status? (Sensor or Time).
            **Start:** The start is *always* done by EMHASS (when sensor.p_deferrableX > 0).
            **Done:** What marks the load as 'done'? (Sensor or EMHASS).
            **Action when Done:** IMPORTANT! Choose whether your device remains ON (1, 2) or is turned OFF (3-6) at the end.
          default: "1"
          selector:
            select:
              options:
                - label: "(1) Wait: Sensor | Done: Sensor | Device: Stays ON"
                  value: "1"
                - label: "(2) Wait: Time | Done: Sensor | Device: Stays ON"
                  value: "2"
                - label: "(3) Wait: Sensor | Done: EMHASS | Device: Turns OFF"
                  value: "3"
                - label: "(4) Wait: Time | Done: EMHASS | Device: Turns OFF"
                  value: "4"
                - label: "(5) Wait: Sensor | Done: Sensor or EMHASS | Device: Turns OFF"
                  value: "5"
                - label: "(6) Wait: Time | Done: Sensor or EMHASS | Device: Turns OFF"
                  value: "6"
        wait_times_hours:
          name: "Time Trigger: Hours"
          description: >
            CRON pattern for the hour (e.g., 10 or /4). Only used for 'Wait: Time' strategies (2, 4, 6).
          default: "0"
          selector:
            text:
              multiline: false
        wait_times_minutes:
          name: "Time Trigger: Minutes"
          description: >
            CRON pattern for the minute (e.g., 30 or /5). Only used for 'Wait: Time' strategies (2, 4, 6).
          default: "5"
          selector:
            text:
              multiline: false
        input_status:
          name: Status Helper (Input Select)
          description: >
            The `input_select` helper that stores the status of this load. MUST have the options: `done`, `wait`, `running` and `force`.
          default:
          selector:
            entity:
              multiple: false
              filter:
                domain: input_select
        input_emhass:
          name: EMHASS JSON Helper (Input Text)
          description: >
            The `input_text` helper (max. 255 characters) where this automation writes its JSON data. This entity must be added in the main `EMHASS Basic Automation` blueprint!
          default:
          selector:
            entity:
              multiple: false
              filter:
                domain: input_text
        input_trigger:
          name: EMHASS Deferrable Sensor
          description: >
            The associated `sensor.p_deferrableX` sensor created by EMHASS. The state of this sensor (> 0) is used to start the load.
          default:
          selector:
            entity:
              multiple: false
              filter:
                domain: sensor
        wait_sensor:
          name: Sensor for 'Wait' Status
          description: >
            The sensor (e.g., power sensor indicating idle) used to set the load to 'wait' status. Only for 'Wait: Sensor' strategies.
          default:
          selector:
            entity:
              multiple: false
              filter:
                domain: sensor
        wait_value:
          name: Threshold for 'Wait' Status
          description: >
            The value that the 'Wait Sensor' **must exceed** to set the status to 'wait'.
          default:
          selector:
            number:
              min: 1
              max: 1000
              step: 1
              mode: box
        skipp_wait_to_force:
          name: Skip 'Wait' and Force 'Running'
          description: >
            When enabled, the automation skips the 'wait' status and goes directly to 'force' ('running') as soon as the 'Wait Sensor' threshold is reached. This starts the load immediately and bypasses EMHASS optimization.
          default: false
          selector:
            boolean:
        running_stabilize_sensors_delay:
          name: Delay to stabilize the 'running' sensors
          description: >
            This value delays the automation's termination by x minutes when the status changes to `running` or `force`. This is primarily needed in `force` mode to stabilize the sensors (defaut = 0).
          default: 0
          selector:
            number:
              min: 0
              max: 100
              step: 1
              mode: box
        stop_sensor:
          name: Sensor for 'Done' Status
          description: >
            The sensor (e.g., power sensor indicating 'finished') used to set the load to 'done' status. Only for 'Done: Sensor' strategies.
          default:
          selector:
            entity:
              multiple: false
              filter:
                domain: sensor
        stop_value:
          name: Threshold for 'Done' Status
          description: >
            The value that the 'Done Sensor' **must fall below** to set the status to 'done'.
          default:
          selector:
            number:
              min: 1
              max: 1000
              step: 1
              mode: box
        stop_value_overwrite:
          name: "'Done' Value Overwrite (for Number)"
          description: >
            (Optional) Only used if 'Load Control Entity' is a `number` or `input_number`. Sets a specific value when the load is 'done'. Set to -1 to use the current value of the 'Done Sensor' instead.
          default: -1
          selector:
            number:
              min: -1
              max: 1000
              step: 1
              mode: box
        update_sensor:
          name: Load Control Entity (Device Control)
          description: >
            (Optional) The entity (`switch`, `input_boolean`, `number` etc.) that controls your physical device. This automation will turn this entity ON or OFF.
            **Leave this blank** if you use a separate, dedicated automation to control your device (e.g., for a complex Wallbox that reacts to the EMHASS sensor directly).
          default: null
          selector:
            entity:
              multiple: false
              filter:
                domain:
                  - number
                  - input_number
                  - switch
                  - input_boolean
        allow_allways_to_done:
          name: Always Allow 'Done' Status
          description: >
            (Advanced) When enabled, the 'Done Sensor' can set the status to 'done' even if the status is not 'running' (e.g., if it is in the 'wait' state).
            This is useful for `si: false` (multi-block) loads that may be manually stopped, or to reset the automation if it gets stuck.
          default: false
          selector:
            boolean:

    # --- EMHASS Deferrable Load
    grid_basic_deferrable_load_config:
      name: EMHASS Load Parameters
      description: >
        Defines the technical parameters of this load. This data is used for EMHASS optimization.
      collapsed: true
      input:
        emhass_config_optimization_time_step:
          name: Optimization Time Step (Minutes)
          description: >
            The `optimization_time_step` from your EMHASS configuration. **MUST** match the value in your `EMHASS Basic Automation` (e.g., 30).
            **Important**: If this is changed, the `start` and `end timestamps` in the load controllers must be adjusted (30 minutes = 2 units, 15 minutes = 4 units per hour).
            In the automation controller, `load_cost_forecast` and `p_pv_forecast` must be adjusted (30 minutes = 48 entries, 15 minutes = 96 entries in the array).
          default: "30"
          selector:
            select:
              options:
                - "60"
                - "30"
                - "15"
        nominal_powers:
          name: Nominal Power (po)
          description: >
            The power consumption of the load in Watts (W) when it is running. (Parameter: `po`)
          default:
          selector:
            number:
              min: 10
              max: 22000
              step: 10
              mode: box
        operating_hours:
          name: Operating Hours (ho)
          description: >
            The total time in hours (e.g., `1.5` for 90 minutes) the load requires for one cycle. Can be a template. (Parameter: `ho`)
          default:
          selector:
            text:
              multiline: true
        start_timesteps:
          name: Earliest Start Timestep (st)
          description: >
            The earliest time the load is allowed to start. This is an index, not a time. (e.g., `0` = 0 Hours, `6` = 3 Hours, for 30min steps). (Parameter: `st`)
          default:
          selector:
            number:
              min: 0
              max: 48
              step: 0.5
              mode: box
        end_timesteps:
          name: Latest End Timestep (et)
          description: >
            The latest time (index) by which the load **must** be finished. (e.g., `12` = 6 Hours, for 30min steps). Can be a template. (Parameter: `et`)
          default:
          selector:
            text:
              multiline: true
        end_timesteps_force_run:
          name: Additional End Timestamps by a force run (optional)
          description: >
            If automation is started via the `force` option, additional end times can be added here. This increases the operating hours (ho). By an force run the
            start timestamp is `0` and the endtimesampt (et) is calculated over the operating hours and this timestamps. This can be useful if an electric car takes
            longer to charge but absolutely must be fully charged.
          default: 0
          selector:
            number:
              min: 0
              max: 96
              step: 1
              mode: box
        deferrable_load_as_semi_cont:
          name: Semi-Continuous Load / Power Modulation (se)
          description: |
            This parameter defines **HOW** the load consumes power. (Parameter: `se`)
            **false (Default):** The load is binary (ON/OFF). When ON, it consumes the full 'Nominal Power' (po).
            **true:** The load is modulatable (variable). When OFF, EMHASS can schedule it to consume any power *between* 'Minimum Power' (mp) and 'Nominal Power' (po). (e.g., a smart EV charger that can adjust its amps).
          default: false
          selector:
            boolean:
        deferrable_load_single_constant:
          name: Single Uninterrupted Block / Time Scheduling (si)
          description: |
            This parameter defines **WHEN** the load runs. (Parameter: `si`)
            **true (Default):** The load is an "uninterruptible block". EMHASS must schedule the *entire* 'Operating Hours' (ho) in one single, continuous time block. (e.g., a dishwasher).
            **false:** The load is "interruptible". EMHASS can split the 'Operating Hours' (ho) into multiple, separate time blocks (e.g., an EV charger that can pause when power is expensive).
          default: true
          selector:
            boolean:
        deferrable_load_single_constant_work:
          name: "Behavior when 'si: false'"
          description: >
            (Advanced) Behavior for interruptible loads (si: false) after a partial run.
            "True" (default) = Return to 'wait' if more runtime is scheduled.
            "False" = Always go to 'done' (useful for surplus-only loads that shouldn't create new demand).
          default: "True"
          selector:
            text:
              multiline: true
        minimum_power_deferrable_load:
          name: Minimum Power (mp)
          description: >
            The minimum power in Watts (W) that must be scheduled when the load is running. (Parameter: `mp`)
          default:
          selector:
            number:
              min: 10
              max: 22000
              step: 10
              mode: box
        deferrable_startup_penalty:
          name: Prioritization Penalty (pe)
          description: >
            A cost/penalty value for starting this load, used for prioritization. A **higher** value gives this load a **lower** priority (it will be scheduled later). (Parameter: `pe`)
          default: 0
          selector:
            number:
              min: 0
              max: 30
              step: 1
              mode: box

    # --- EMHASS Notify & Logging
    grid_basic_notify_config:
      name: Notifications & Logging
      description: >
        (Optional) Sends notifications when the load's status changes.
      collapsed: true
      input:
        notify_wait:
          name: "'Wait' Notification"
          description: >
            (Optional) Message sent when the load changes to 'wait' status.
          default: ""
          selector:
            text:
              type: text
        notify_running:
          name: "'Running' Notification"
          description: >
            (Optional) Message sent when the load starts ('running').
          default: ""
          selector:
            text:
              type: text
        notify_done:
          name: "'Done' Notification"
          description: >
            (Optional) Message sent when the load is finished ('done').
          default: ""
          selector:
            text:
              type: text
        notify_group:
          name: Notification Service
          description: >
            The notification service to use. Example: "mobile_app_handy" ; importantly, it must be in the notify domain.
          default:
          selector:
            text:
              type: text
        automation_trace_count:
          name: Number of traces
          description: >
            Number of traces to be saved by this automation
          default: 10
          selector:
            number:
              min: 5
              max: 90
              step: 1
              mode: box
        automation_logger_level:
          name: Automation logger level
          description: >
            The logging level for this automation.
          default: INFO
          selector:
            select:
              options:
                - label: DEBUG
                  value: DEBUG
                - label: WARNING
                  value: WARNING
                - label: INFO
                  value: INFO

# ----------------------------
# --- EMHASS Trigger Variables
# ----------------------------

variables:
  blueprint_version: v202601
  automation_logger_name: homeassistant.components.automation.{{ this.entity_id.split('.')[1] }}
  input_automation_logger_level: !input automation_logger_level
  input_automation_trace_count: !input automation_trace_count
  emhass_step: !input emhass_config_optimization_time_step
  input_allow_allways_to_done: !input allow_allways_to_done
  input_trigger_strategy: !input trigger_strategy
  input_trigger_sensor: !input input_trigger
  input_update_sensor: !input update_sensor
  input_status_sensor: !input input_status
  input_notify_group: !input notify_group
  input_notify_wait: !input notify_wait
  input_notify_running: !input notify_running
  input_notify_done: !input notify_done
  input_wait_sensor: !input wait_sensor
  input_wait_value: !input wait_value
  input_skipp_wait_to_force: !input skipp_wait_to_force
  input_running_stabilize_sensors_delay: !input running_stabilize_sensors_delay
  input_wait_times_hours: !input wait_times_hours
  input_wait_times_minutes: !input wait_times_minutes
  input_stop_sensor: !input stop_sensor
  input_stop_value: !input stop_value
  input_stop_value_overwrite: !input stop_value_overwrite
  input_emhass_sensor: !input input_emhass
  input_po: !input nominal_powers
  input_st: !input start_timesteps
  input_se: !input deferrable_load_as_semi_cont
  input_si: !input deferrable_load_single_constant
  input_si_work: !input deferrable_load_single_constant_work
  input_mp: !input minimum_power_deferrable_load
  input_pe: !input deferrable_startup_penalty
  input_ho: !input operating_hours
  input_end_timesteps: !input end_timesteps
  input_end_timesteps_force_run: !input end_timesteps_force_run

  # Read in all currently available values and save it read-only in this variable
  snapshot: >
    {% set status_json = states(input_emhass_sensor | string) | from_json(default={}) %}
    {% set now_dt = now() %}
    {% set snapshot_base = {
      "current_time": now_dt | as_datetime | as_local | string,
      "automation_logger_level": input_automation_logger_level | default('info') | string | lower,
      "automation_po": input_po | int,
      "automation_ho": input_ho | float(0),
      "automation_st": input_st | default (0) | int,
      "automation_et": input_end_timesteps | default(0) | int,
      "automation_se": input_se | default(false) | bool,
      "automation_si": input_si | default(true) | bool,
      "automation_si_work": input_si_work | default(true) | bool,
      "automation_mp": input_mp | default(1) | int,
      "automation_pe": input_pe | default(0) | int,
      "automation_et_force": input_end_timesteps_force_run | default(0) | int,
      "allow_allways_to_done_value": input_allow_allways_to_done | default(false) | bool,
      "trigger_strategy_value": input_trigger_strategy | default("1") | string,
      "trigger_sensor_name": input_trigger_sensor | string,
      "trigger_sensor_value": states(input_trigger_sensor | string) | default(0) | int,
      "trigger_sensor_attribute_name": (input_trigger_sensor | string).split('.')[-1],
      "update_sensor_name": input_update_sensor | string,
      "update_sensor_type": (input_update_sensor | string).split('.')[0],
      "status_sensor_name": input_status_sensor | string,
      "status_sensor_value": states(input_status_sensor | string) | default('done') | string,
      "status_sensor_changed": states[(input_status_sensor | string)].last_changed | as_datetime | as_local | string,
      "status_sensor_changed_by_user": (states.person | selectattr('attributes.user_id', 'eq', states[(input_status_sensor | string)].context.user_id) | list) | length > 0,
      "status_json_sensor_name": input_emhass_sensor | string,
      "status_json_sensor_value": status_json | string,
      "status_json_sensor_changed": states[(input_emhass_sensor | string)].last_changed | as_datetime | as_local | string,
      "status_json_sensor_changed_by_user": (states.person | selectattr('attributes.user_id', 'eq', states[(input_emhass_sensor | string)].context.user_id) | list) | length > 0,
      "notify_group_name": input_notify_group | default('') | string,
      "notify_wait_message": input_notify_wait | default('') | string,
      "notify_running_message": input_notify_running | default('') | string,
      "notify_done_message": input_notify_done | default('') | string,
      "wait_sensor_name": input_wait_sensor | string,
      "wait_sensor_value": states(input_wait_sensor | string) | default(0) | float,
      "wait_sensor_threshold": input_wait_value | default(1) | int,
      "skipp_wait_to_force_value": input_skipp_wait_to_force | default(false) | bool,
      "running_stabilize_sensors_delay": input_running_stabilize_sensors_delay | default(0) | int(0),
      "wait_times_hours_value": input_wait_times_hours | default('0') | string,
      "wait_times_minutes_value": input_wait_times_minutes | default('5') | string,
      "stop_sensor_name": input_stop_sensor | string,
      "stop_sensor_value": states(input_stop_sensor | string) | default(0) | float,
      "stop_sensor_overwrite_value": input_stop_value_overwrite | default(-1) | int,
      "stop_sensor_threshold": input_stop_value | default(1) | int,
      "emhass_step_value": emhass_step | default(30) | int,
      "emhass_step_value_hour": (1 / (60 / (emhass_step | default(30) | int))) | default(0.5) | float,
      "emhass_current_time_delta": (now_dt - timedelta(minutes=(emhass_step | default(30) | int))) | as_datetime | as_local | string,
      "emhass_po": status_json['po'] | default(1) | int,
      "emhass_ho": status_json['ho'] | default(0) | float,
      "emhass_st": status_json['st'] | default(0) | int,
      "emhass_et": status_json['et'] | default(0) | int,
      "emhass_se": status_json['se'] | default(false) | bool,
      "emhass_si": status_json['si'] | default(true) | bool,
      "emhass_mp": status_json['mp'] | default(1) | int,
      "emhass_pe": status_json['pe'] | default(0) | int,
      "emhass_us": status_json['us'] | default('done') | string,
      "emhass_ss": status_json['ss'] | default(0) | int
    } %}
    {% set ns = namespace(count=0, count_done=0, count_open=0, power=0, power_done=0, power_done_min=0,
        power_done_max=0, power_open=0, power_open_min=0, power_open_max=0)
    %}
    {% for item in (state_attr(snapshot_base.trigger_sensor_name, 'deferrables_schedule') | default([])) %}
      {% set p = item[snapshot_base.trigger_sensor_attribute_name] | float(0) %}
      {% set d = item.date | as_datetime %}
      {% set ns.count = ns.count + 1 %}
      {% set ns.power = ns.power + p %}
      {% if d >= (now_dt - timedelta(minutes=(snapshot_base.emhass_step_value | default(30) | int))) %}
        {% set ns.count_open = ns.count_open + 1 %}
        {% set ns.power_open = ns.power_open + p %}
        {% if p > 0 %}
          {% if ns.power_open_min <= 0 %}
            {% set ns.power_open_min = p %}
          {% else %}
            {% set ns.power_open_min = [ns.power_open_min, p] | min %}
          {% endif %}
          {% set ns.power_open_max = [ns.power_open_max, p] | max %}
        {% endif %}
      {% else %}
        {% if ns.power_done_min <= 0 %}
          {% set ns.power_done_min = p %}
        {% else %}
          {% set ns.power_done_min = [ns.power_done_min, p] | min %}
        {% endif %}
        {% set ns.power_done_max = [ns.power_done_max, p] | max %}
        {% set ns.count_done = ns.count_done + 1 %}
        {% set ns.power_done = ns.power_done + p %}
      {% endif %}
    {% endfor %}
    {% set def = {
      "emhass_deferrable_count": ns.count,
      "emhass_deferrable_count_done": ns.count_done,
      "emhass_deferrable_count_open": ns.count_open,
      "emhass_deferrable_power": ns.power,
      "emhass_deferrable_power_done": ns.power_done,
      "emhass_deferrable_power_done_min": ns.power_done_min,
      "emhass_deferrable_power_done_max": ns.power_done_max,
      "emhass_deferrable_power_open": ns.power_open,
      "emhass_deferrable_power_open_min": ns.power_open_min,
      "emhass_deferrable_power_open_max": ns.power_open_max
    } %}
    {{ (snapshot_base | combine(def)) | to_json }}

# ---------------------------
# --- EMHASS Trigger Triggers
# ---------------------------

triggers:

  - trigger: numeric_state
    entity_id:
      - !input wait_sensor
    above: !input wait_value
    for: "00:00:05"
    id: wait_sensor_value_above
  - trigger: state
    entity_id:
      - !input input_trigger
    from: null
    to: null
    for: "00:00:05"
    id: input_sensor_value_changed
  - trigger: numeric_state
    entity_id:
      - !input input_trigger
    above: 0
    for: "00:00:05"
    id: input_sensor_value_above
  - trigger: numeric_state
    entity_id:
      - !input stop_sensor
    below: !input stop_value
    for: "00:00:05"
    id: stop_sensor_value_above
  - trigger: numeric_state
    entity_id:
      - !input input_trigger
    below: 1
    for: "00:00:05"
    id: input_sensor_value_below
  - trigger: state
    entity_id:
      - !input input_status
    not_to:
      - unknown
      - unavailable
    not_from:
      - unknown
      - unavailable
    for: "00:00:05"
    id: input_state_changed
  - trigger: time_pattern
    hours: !input wait_times_hours
    minutes: !input wait_times_minutes
    seconds: 3
    id: cron

# -----------------------------
# --- EMHASS Trigger Conditions
# -----------------------------

conditions:

  - condition: template
    value_template: >
      {{
        has_value((snapshot | from_json).status_sensor_name) and
        has_value((snapshot | from_json).status_json_sensor_name) and
        has_value((snapshot | from_json).trigger_sensor_name)
      }}

  - condition: template
    value_template: >
      {% set config = snapshot | from_json %}
      {% set automation_trigger_id = trigger.id | default('none') | string | lower %}
      {% set is_user_action = config.status_sensor_changed_by_user == true and
        as_timestamp(config.current_time) - as_timestamp(config.status_sensor_changed) < 10 %}
      {% if is_user_action == true and automation_trigger_id == 'input_state_changed' %}
        {{ true }}
      {% elif is_user_action == false and automation_trigger_id != 'input_state_changed' %}
        {{ true }}
      {% else %}
        {{ false }}
      {% endif %}

# --------------------------
# --- EMHASS Trigger Actions
# --------------------------

actions:

   # --- Create output variable
  - variables:
      context: >
        {% set config = snapshot | from_json %}
        {% set automation_trigger_id = trigger.id | default('none') | string | lower %}

        {# --- User Action Detection --- #}
        {% set is_user_action = config.status_sensor_changed_by_user == true and
          as_timestamp(config.current_time) - as_timestamp(config.status_sensor_changed) < 10 %}

        {# --- Initialize Result Namespace --- #}
        {% set res = namespace(action_needed = false, sensor_value_number = 0,
          sensor_value_switch = 'off', target_status = 'none',
          new_po = config.automation_po, new_ho = config.automation_ho,
          new_st = config.automation_st, new_et = config.automation_et,
          new_se = config.automation_se, new_si = config.automation_si,
          new_mp = config.automation_mp, new_pe = config.automation_pe,
          new_us = 'none', new_ss = config.emhass_ss, new_running_sensors_delay = 0,
          notify_enabled = false, notify_message = '',
          automation_action = 'none', log_msg = [])
        %}

        {# --- New State Maschine --- #}
        {% if is_user_action == true %}
          {% if config.status_sensor_value == 'wait' %}
            {% set res.log_msg = res.log_msg + ['User switched to state wait'] %}
            {% set res.automation_action = 'wait' %}
          {% elif config.status_sensor_value == 'running' %}
            {% set res.log_msg = res.log_msg + ['User switched to state running'] %}
            {% set res.automation_action = 'running' %}
          {% elif config.status_sensor_value == 'force' or ((config.status_sensor_value).startswith('force-')) %}
            {% set res.log_msg = res.log_msg + ['User switched to state force'] %}
            {% set res.automation_action = 'running' %}
          {% elif config.status_sensor_value == 'done' %}
            {% set res.log_msg = res.log_msg + ['User switched to state done'] %}
            {% set res.automation_action = 'done' %}
          {% else %}
            {% set res.log_msg = res.log_msg + ['User switched to unknow state: ' ~ config.status_sensor_value] %}
          {% endif %}
        {% else %}
          {% if
              config.wait_sensor_value > config.wait_sensor_threshold and
              config.emhass_us == 'done' and
              config.automation_ho >= config.emhass_step_value_hour and
              config.trigger_strategy_value in ['1', '3', '5']
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state wait (1000)'] %}
            {% set res.automation_action = 'wait' %}
          {% elif
              automation_trigger_id == 'cron' and
              config.emhass_us == 'done' and
              config.automation_ho >= config.emhass_step_value_hour and
              config.trigger_strategy_value in ['2', '4', '6']
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state wait (1010)'] %}
            {% set res.automation_action = 'wait' %}
          {% elif
              config.emhass_us in ['running', 'wait'] and
              config.emhass_deferrable_power_open > 0 and
              config.trigger_sensor_value == 0 and
              config.automation_si == false and
              config.automation_si_work == true
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state wait (1020)'] %}
            {% set res.automation_action = 'wait' %}
          {% elif
            (config.emhass_us == 'force' or ((config.emhass_us).startswith('force-'))) and
            config.stop_sensor_value >= config.stop_sensor_threshold and
            (
              (config.status_sensor_value in ['wait', 'running', 'force'] or ((config.status_sensor_value).startswith('force-'))) or
              config.trigger_sensor_value > 0
            )
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state force running by emhass sensor (1100)'] %}
            {% set res.automation_action = 'running' %}
          {% elif
            config.emhass_us == 'wait' and
            (
              (
                config.stop_sensor_value >= config.stop_sensor_threshold and
                config.status_sensor_value == 'wait'
              ) or (
                config.trigger_sensor_value > 0
              )
            )
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state running by emhass sensor (1110)'] %}
            {% set res.automation_action = 'running' %}
          {% elif
            (config.emhass_us in ['running', 'force'] or ((config.emhass_us).startswith('force-'))) and
            (config.status_sensor_value in ['running', 'force'] or ((config.status_sensor_value).startswith('force-'))) and
            config.wait_sensor_value > config.wait_sensor_threshold and
            config.trigger_sensor_value > 0
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state running by emhass sensor (1120)'] %}
            {% set res.automation_action = 'running' %}
          {% elif
            config.stop_sensor_value < config.stop_sensor_threshold and
            config.trigger_strategy_value in ['1', '2', '5', '6'] and
            (
              (config.emhass_us in ['running', 'force', 'none', 'done'] or ((config.emhass_us).startswith('force-'))) or
              config.allow_allways_to_done_value == true
            )
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state done by stop sensor (1200)'] %}
            {% set res.automation_action = 'done' %}
          {% elif
            config.trigger_sensor_value == 0 and
            config.trigger_strategy_value in ['3', '4', '5', '6'] and
            (
              (config.emhass_us in ['running', 'force', 'none', 'done'] or ((config.emhass_us).startswith('force-'))) or
              config.allow_allways_to_done_value == true
            )
          %}
            {% set res.log_msg = res.log_msg + ['Automation switched to state done by emhass sensor (1210)'] %}
            {% set res.automation_action = 'done' %}
          {% else %}
            {% set res.log_msg = res.log_msg + ['Can not switch to new state. No state found. (1300)'] %}
          {% endif %}
        {% endif %}

        {# --- Got to wait --- #}
        {% if res.automation_action == 'wait' %}
          {% set res.log_msg = res.log_msg + ['Go to status wait'] %}
          {% set res.new_us = 'wait' if config.skipp_wait_to_force_value == false else 'force' %}
          {% set res.target_status = res.new_us %}
          {% set res.notify_enabled = config.notify_wait_message is not none and config.notify_wait_message != '' %}
          {% set res.notify_message = config.notify_wait_message %}
          {% set res.new_ss = config.emhass_ss if config.emhass_ss > 0 else as_timestamp(config.current_time) | int %}

        {# --- Got to running (force) --- #}
        {% elif res.automation_action == 'running' %}
          {% set res.log_msg = res.log_msg + ['Go to status running'] %}
          {% set res.new_running_sensors_delay = config.running_stabilize_sensors_delay %}
          {% if
              (config.emhass_us in ['running', 'force'] or ((config.emhass_us).startswith('force-'))) and
              (
                config.emhass_us == config.status_sensor_value or
                config.emhass_si == true
              )
          %}
            {% set res.log_msg = res.log_msg + ['The status is already in a running state: ' + config.emhass_us] %}
          {% else %}
            {% set res.notify_enabled = config.notify_running_message is not none and config.notify_running_message != '' %}
            {% set res.notify_message = config.notify_running_message %}
            {% set res.new_ss = config.emhass_ss if config.emhass_ss > 0 else as_timestamp(config.current_time) | int %}
            {% if (config.status_sensor_value == 'force' or ((config.status_sensor_value).startswith('force-'))) %}
              {% set res.log_msg = res.log_msg + ['Set force running options'] %}
              {% set res.new_us = config.status_sensor_value %}
              {% set res.target_status = res.new_us %}
              {% set res.new_si = true %}
              {% set res.new_se = false %}
              {% set res.new_st = 0 %}
              {% set res.new_ho = config.automation_ho + ((config.automation_et_force * config.emhass_step_value) / 60) %}
              {% set res.new_et = (res.new_ho / config.emhass_step_value_hour) | int %}
            {% else %}
              {% set res.log_msg = res.log_msg + ['Set running options'] %}
              {% set res.new_us = 'running' %}
              {% set res.target_status = res.new_us %}
            {% endif %}
            {% if config.update_sensor_type in ['number', 'input_number'] %}
              {% set res.sensor_value_number = config.wait_sensor_value %}
            {% else %}
              {% set res.sensor_value_switch = 'on' %}
            {% endif %}
          {% endif %}

        {# --- Got to done --- #}
        {% elif res.automation_action == 'done' %}
          {% set res.log_msg = res.log_msg + ['Go to status done'] %}
          {% set res.new_us = 'done' %}
          {% set res.target_status = res.new_us %}
          {% set res.notify_enabled = config.notify_done_message is not none and config.notify_done_message != '' %}
          {% set res.notify_message = config.notify_done_message %}
          {% set res.new_ss = 0 %}
          {% set res.new_ho = 0 %}
          {% if config.update_sensor_type in ['number', 'input_number'] %}
            {% set res.sensor_value_number = config.stop_sensor_value if config.stop_sensor_overwrite_value == -1 else config.stop_sensor_overwrite_value %}
          {% else %}
            {% if config.trigger_strategy_value in ['3', '4', '5', '6'] %}
              {% set res.sensor_value_switch = 'off' %}
            {% else %}
              {% set res.sensor_value_switch = 'on' %}
            {% endif %}
          {% endif %}

        {# --- State change are not allowed --- #}
        {% else %}
          {% set res.log_msg = res.log_msg + ['No state found. (1310)'] %}
        {% endif %}

        {# --- Create a new target JSON and ensure that our JSON is not modified if a plan has already been created --- #}
        {# --- A new calculation can only be generated via the status 'done' -> 'wait' --- #}
        {% set json_override_allowed = (res.new_ss > 0 and config.emhass_ss == 0) or (res.new_us == 'done') or (config.emhass_deferrable_power_open == 0) %}
        {% set result_target_json = {
            'po': res.new_po if json_override_allowed else config.emhass_po,
            'ho': res.new_ho if json_override_allowed else config.emhass_ho,
            'st': res.new_st if json_override_allowed else config.emhass_st,
            'et': res.new_et if json_override_allowed else config.emhass_et,
            'se': res.new_se if json_override_allowed else config.emhass_se,
            'si': res.new_si if json_override_allowed else config.emhass_si,
            'mp': res.new_mp if json_override_allowed else config.emhass_mp,
            'pe': res.new_pe if json_override_allowed else config.emhass_pe,
            'us': res.new_us,
            'ss': res.new_ss
          }
        %}

        {# --- Action are needed --- #}
        {% if res.new_us == 'none' %}
          {% set res.action_needed = false %}
        {% else %}
          {% set res.action_needed = config.status_json_sensor_value != (result_target_json | string) %}
        {% endif %}

        {{ {
          'automation': {
            'trigger_id': automation_trigger_id,
            'logger_level': config.automation_logger_level,
            'is_user_action': is_user_action,
            'running_sensors_delay': res.new_running_sensors_delay
          },
          'source_json': {
            'po': config.emhass_po,
            'ho': config.emhass_ho,
            'st': config.emhass_st,
            'et': config.emhass_et,
            'se': config.emhass_se,
            'si': config.emhass_si,
            'mp': config.emhass_mp,
            'pe': config.emhass_pe,
            'us': config.emhass_us,
            'ss': config.emhass_ss
          },
          'result': {
            'action_needed': res.action_needed,
            'target_status': res.target_status,
            'target_json': result_target_json,
            'sensor': {
              'type': config.update_sensor_type,
              'name': config.update_sensor_name,
              'value_number': res.sensor_value_number,
              'value_switch': res.sensor_value_switch
            },
            'notify': {
              'enabled': res.notify_enabled,
              'group': config.notify_group_name,
              'message': res.notify_message
            }
          },
          'logs': res.log_msg
        } | to_json }}

  # --- Run EMHASS Actions
  - alias: Logging
    parallel:
    - alias: Info logging
      if:
        - condition: template
          value_template: >
            {% set config = context | from_json %}
            {{ config.automation.logger_level == 'info' }}
      then:
        - service: system_log.write
          data:
            level: info
            logger: "{{ automation_logger_name }}"
            message: >
              [INFO]:
              result data: {{ (context | from_json).result }}
              logs: {{ (context | from_json).logs }}
    - alias: Warning logging
      if:
        - condition: template
          value_template: >
            {% set config = context | from_json %}
            {{ config.automation.logger_level in ['debug', 'warning'] }}
      then:
        - service: system_log.write
          data:
            level: warning
            logger: "{{ automation_logger_name }}"
            message: >
              [WARNING]:
              result data: {{ (context | from_json).result }}
              logs: {{ (context | from_json).logs }}
    - alias: Debug logging
      if:
        - condition: template
          value_template: >
            {% set config = context | from_json %}
            {{ config.automation.logger_level == 'debug' }}
      then:
        - service: system_log.write
          data:
            level: warning
            logger: "{{ automation_logger_name }}"
            message: >
              [DEBUG]:
              snapshot: {{ snapshot }}
              context: {{ context | from_json }}

  - alias: Update EMHASS Trigger fields
    if:
      - condition: template
        value_template: >
          {% set config = context | from_json %}
          {{ config.result.action_needed | default(true) | bool }}
    then:
      - alias: Set trigger options in parallel mode
        parallel:
        - alias: Set trigger sensor switch to off
          if:
            - condition: template
              value_template: >
                {% set config = context | from_json %}
                {{ config.result.sensor.type == 'switch' and config.result.sensor.value_switch == 'off' }}
          then:
            - action: switch.turn_off
              target:
                entity_id: !input update_sensor
        - alias: Set trigger sensor input_boolean to off
          if:
            - condition: template
              value_template: >
                {% set config = context | from_json %}
                {{ config.result.sensor.type == 'input_boolean' and config.result.sensor.value_switch == 'off' }}
          then:
            - action: input_boolean.turn_off
              target:
                entity_id: !input update_sensor
        - alias: Set trigger sensor switch to on
          if:
            - condition: template
              value_template: >
                {% set config = context | from_json %}
                {{ config.result.sensor.type == 'switch' and config.result.sensor.value_switch == 'on' }}
          then:
            - action: switch.turn_on
              target:
                entity_id: !input update_sensor
        - alias: Set trigger sensor input_boolean to on
          if:
            - condition: template
              value_template: >
                {% set config = context | from_json %}
                {{ config.result.sensor.type == 'input_boolean' and config.result.sensor.value_switch == 'on' }}
          then:
            - action: input_boolean.turn_on
              target:
                entity_id: !input update_sensor
        - alias: Set trigger sensor number to value
          if:
            - condition: template
              value_template: >
                {% set config = context | from_json %}
                {{ config.result.sensor.type == 'number' and config.result.target_status != 'wait' }}
          then:
            - action: number.set_value
              data:
                value: >
                  {% set config = context | from_json %}
                  {{ config.result.sensor.value_number | default(0) | float }}
              target:
                entity_id: !input update_sensor
        - alias: Set trigger sensor input_number to value
          if:
            - condition: template
              value_template: >
                {% set config = context | from_json %}
                {{ config.result.sensor.type == 'input_number' and config.result.target_status != 'wait' }}
          then:
            - action: input_number.set_value
              data:
                value: >
                  {% set config = context | from_json %}
                  {{ config.result.sensor.value_number | default(0) | float }}
              target:
                entity_id: !input update_sensor

      - alias: Set Trigger status and json in parallel mode
        parallel:
        - alias: Update Trigger status
          action: input_select.select_option
          data:
            option: >
              {% set config = context | from_json %}
              {{ config.result.target_status | default(done) | string }}
          target:
            entity_id: !input input_status
        - alias: Update EMHASS settings
          action: input_text.set_value
          data:
            value: >
              {% set config = context | from_json %}
              {{ config.result.target_json | to_json }}
          target:
            entity_id: !input input_emhass

      - alias: Send notification
        if:
          - condition: template
            value_template: >
              {% set config = context | from_json %}
              {{ config.result.notify.enabled | default(false) | bool }}
        then:
          - alias: Send Message
            action: >
              {% set config = context | from_json %}
              notify.{{ config.result.notify.group | string }}
            data:
              message: >
                {% set config = context | from_json %}
                {{ config.result.notify.message }}

  - alias: Wait for running sensor delay
    delay:
      hours: 0
      minutes: >
        {% set config = context | from_json %}
        {{ config.automation.running_sensors_delay | default(0) | int(0) }}
      seconds: 0
      milliseconds: 1

# -------------------
# --- Automation Mode
# -------------------

mode: single
max_exceeded: silent
trace:
  stored_traces: !input automation_trace_count
